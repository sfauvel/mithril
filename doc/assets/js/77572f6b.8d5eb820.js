"use strict";(self.webpackChunkmithril_doc=self.webpackChunkmithril_doc||[]).push([[8051],{1531:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=t(85893),r=t(3905);const o={slug:4,title:"4. Mithril Network Upgrade Strategy\n",authors:[{name:"Mithril Team"}],tags:["Draft"],date:new Date("2023-01-05T00:00:00.000Z")},i=void 0,s={permalink:"/doc/adr/4",source:"@site/adr/004-mithril-network-update-strategy.md",title:"4. Mithril Network Upgrade Strategy\n",description:"Status",date:"2023-01-05T00:00:00.000Z",formattedDate:"January 5, 2023",tags:[{label:"Draft",permalink:"/doc/adr/tags/draft"}],readingTime:3.97,hasTruncateMarker:!1,authors:[{name:"Mithril Team"}],frontMatter:{slug:"4",title:"4. Mithril Network Upgrade Strategy\n",authors:[{name:"Mithril Team"}],tags:["Draft"],date:"2023-01-05T00:00:00.000Z"},unlisted:!1,prevItem:{title:"5. Use rfc3339 for date formatting \n",permalink:"/doc/adr/5"},nextItem:{title:"3. Release process and versioning\n",permalink:"/doc/adr/3"}},h={authorsImageUrls:[void 0]},l=[{value:"Status",id:"status",level:2},{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Consequences",id:"consequences",level:2},{value:"Release Team",id:"release-team",level:3},{value:"Version monitoring",id:"version-monitoring",level:3},{value:"Era Activation Marker",id:"era-activation-marker",level:3},{value:"Behavior Switch",id:"behavior-switch",level:3}];function c(e){const n={h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",p:"p",strong:"strong",ul:"ul",...(0,r.ah)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"status",children:"Status"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Draft"})}),"\n",(0,a.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,a.jsx)(n.p,{children:"When we will run Mithril on mainnet there will be thousands of signers running. Upgrading the version of the nodes has an impact as different versions of API, messages, signature may lead to loss of a significant part of the signers population over one epoch or more. In any case we must prevent a gap in the certificate chain while upgrading critical parts."}),"\n",(0,a.jsx)(n.p,{children:"We need to be able to keep enough of signer nodes and the aggregator able to work together in order to produce at least one certificate per epoch."}),"\n",(0,a.jsx)(n.p,{children:"Examples of such changes:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"change in the message structure"}),"\n",(0,a.jsx)(n.li,{children:"change in the cryptographic algorithm"}),"\n",(0,a.jsx)(n.li,{children:"change in communication channels"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,a.jsx)(n.p,{children:"In order to synchronize all nodes behavior transition, the Release Team will define Eras that start at a given Cardano Epoch and lasts until the next Era begins. When nodes detect an Era change, they switch from old to new behavior hence all transitioning at almost the same time."}),"\n",(0,a.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,a.jsx)(n.h3,{id:"release-team",children:"Release Team"}),"\n",(0,a.jsxs)(n.p,{children:["The release team is the team responsible of releasing new versions of Mithril software. The ",(0,a.jsx)(n.strong,{children:"Release Team"})," will be responsible to set the Epoch at which ",(0,a.jsx)(n.strong,{children:"Eras"})," change using an ",(0,a.jsx)(n.strong,{children:"Era Activation Marker"}),". In order to be able to determine when the new Era will begin, the Release Team has to know what is the share of the total Mithril stake that can run the new behavior. Signer node software versions has to be ",(0,a.jsx)(n.strong,{children:"monitored"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"version-monitoring",children:"Version monitoring"}),"\n",(0,a.jsx)(n.p,{children:"The Release Team must be aware of the software version run by the Signer nodes and their associated stake. The version is going to be added to all HTTP headers in inter-node communication. In a first step, the Aggregator nodes will record this information, and provide the mapping of stakes to Signer nodes."}),"\n",(0,a.jsx)(n.p,{children:"This configuration works in the case where there is a centralized Aggregator Node (as it is today). In the future, there may be several Aggregator nodes working in a decentralized manner. This would mean having a separate monitoring service, and also monitor the aggregators node versions."}),"\n",(0,a.jsx)(n.h3,{id:"era-activation-marker",children:"Era Activation Marker"}),"\n",(0,a.jsx)(n.p,{children:"An Era Activation Marker is an information shared among all the nodes. For every upgrade, there are two phases:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"a first marker is set on the blockchain that just indicates a new Era will start soon and softwares shall be updated."}),"\n",(0,a.jsx)(n.li,{children:"a second marker is set that specifies the Epoch when they must switch from old to new behavior."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Every Era Activation Marker will be a transaction in the Cardano blockchain. This implies the nodes must be able to read transactions of the blockchain. Era Activation Markers can be of the same type, the first maker does not hold any Epoch information whereas the second does."}),"\n",(0,a.jsx)(n.p,{children:"Node will check the blockchain for Markers at startup and for every new Epoch. When a node detects a Marker, it will warn the user if it does not support the incoming Era that he must upgrade his node. If the node detects it does not support the current Era, it will stop working with an explicit error message. To ease that operation, Era Activation Marker will be made sortable."}),"\n",(0,a.jsx)(n.h3,{id:"behavior-switch",children:"Behavior Switch"}),"\n",(0,a.jsx)(n.p,{children:"The nodes must be able to switch from one behavior to another when the Era Epoch is reached. This means the software must embed both behaviors. The switch is developed as a one time operation, there is no rollback mechanism available. Once the Epoch is transitioned and the switch has occurred, a new software release can remove the old behavior from the codebase."}),"\n",(0,a.jsx)(n.mermaid,{value:"sequenceDiagram\n    actor Release Team\n    actor User\n    Release Team--xChain: New Era coming soon.\n    Note over Chain: new Epoch\n    Old Node->>Chain: What is the latest marker?\n    Chain->>Old Node: Era change soon\n    New Node->>Chain: What is the last marker?\n    Chain->>New Node: Era change soon\n    Note over New Node: upgrade\n    Loop every Epoch\n        Note over Chain: new Epoch\n        Old Node->>Chain: What is the last marker?\n        Chain->>Old Node: Era change soon\n        Old Node->>User: \u26a0\ufe0f new Era incoming, please update node\n        New Node->>Chain: What is the last marker?\n        Chain->>New Node: Era change soon\n    end\n    Release Team--xChain: New Era start at Epoch XX.\n    Loop every Epoch\n        Note over Chain: new Epoch\n        Old Node->>Chain: What is the last marker?\n        Chain->>Old Node: Era change at Epoch XX\n        Old Node->>User: \u26a0\ufe0f new Era incoming, please update node\n        New Node->>Chain: What is the last marker?\n        Chain->>New Node: Era change at Epoch XX\n    end\n    Note over Chain: Epoch XX\n    Note over Old Node,New Node: new Era\n    New Node->>Chain: What is the last marker?\n    Chain->>New Node: Era change at Epoch XX\n    Note over New Node: switch behavior\n    Old Node->>Chain: What is the last marker?\n    Chain->>Old Node: Era change at Epoch XX\n    Old Node->>User: \ud83d\udc80 unsupported Era, quit."})]})}function d(e={}){const{wrapper:n}={...(0,r.ah)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},3905:(e,n,t)=>{t.d(n,{ah:()=>l});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var h=a.createContext({}),l=function(e){var n=a.useContext(h),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,h=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=l(t),m=r,u=p["".concat(h,".").concat(m)]||p[m]||c[m]||o;return t?a.createElement(u,i(i({ref:n},d),{},{components:t})):a.createElement(u,i({ref:n},d))}));d.displayName="MDXCreateElement"}}]);